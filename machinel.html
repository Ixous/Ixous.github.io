<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Import Katex -->
    <link rel="stylesheet" href="katex/katex.min.css">
    <script src="katex/katex.min.js"></script>
    <!-- Import Katex auto-render -->
    <script src="katex/contrib/auto-render.min.js"></script>

    <meta charset="UTF-8">
    <link rel="stylesheet" href="articles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Supervised learning</title>
</head>
<body>
    <div id="content">
        <a id="indexlink" href="index.html" style="margin-bottom: 30px">
            Go back to the list of projects
        </a>
        <img class="banner_img" src="machinel.png" alt="">
        <div id="page_title">
            Supervised learning assignment
        </div>
        <div id="page_date">
            22/09/2019
        </div>

        <p class="text">
            This project is the first assignment of CS-7641 Machine Learning at the Georgia Institute of Technology. The assignment is to use a library to apply five machine learning algorithms to two datasets, study the effects of two hyper-parameters for each algorithm and compare the results.
        </p>


        <p class="chapter">Datasets</p>


        <p class="section">Wine review</p>

        <p class="text">
            The first dataset I chose is Wine Reviews scraped from WineEnthusiast in June 2017 by <i>zackthoutt</i> and available on Kaggle. It consists of over 280k wines with their review by the website. The categories are :
        </p>
        <ul class="text">
            <li>Country</li>
            <li>Province</li>
            <li>Region_1 and Region_2</li>
            <li>Winery</li>
            <li>Variety</li>
            <li>Designation (name)</li>
            <li>Description (written by the website)</li>
            <li>Price</li>
            <li>Points (score given by the website)</li>
        </ul>
        <p class="text">
            There are also some categories only available on half of the dataset that I dropped immediately. Some of the wines did not have a price or a point score so I dropped them, shrinking the dataset to 258145 entries.
        </p>
        <p class="text">
            The price is a floating-point value in USD and the points are integers in the range from 80 to 100.
        </p>
        <p class="text">
            The value I want to try to predict is the score of the wine, which gives an idea of the actual quality. However, to classify, 21 values is too many. I therefore grouped the wines in 5 grades from 0 to 4, analogous to a star system. This number can be tweaked and will affect the accuracy of the classifiers.
        </p>
        <p class="text">
            As the original point score forms a bell-shaped distribution around a score of 87, the resulting grouping is also a bell-shaped distribution around 1 and 2. Therefore, the dataset is unbalanced, that is the outputs are not distributed evenly.
        </p>
        <div class="center_block">
            <img class="image_small" src="machinel/Hist_WR.svg" alt="">
            <p class="caption">
                Distribution of score after grouping
            </p>
        </div>
        <p class="text">
            From this distribution, we could create a na√Øve distribution classifier, that is a classifier guessing by randomly generating the output with the same distribution as the dataset. We can calculate the accuracy of such learner.
        </p>
        <p class="text">
            Let ùëùùëñ be the proportion of class ùëñ within the dataset. It is also the probability of getting an entry of class ùëñ by randomly picking in the dataset, and the probability of guessing right the class of a random entry in the dataset.
        </p>
        <p class="text">
            Thus, when picking a random entry, the probability of picking one of class ùëñ and correctly guessing its class is $$\pi^2$$. 
        </p>
        <p class="text">
            The total accuracy is therefore $$\Sigma_i p_i^2$$. 
        </p>
        <p class="text">
            For this dataset, we get a distribution classifier with an accuracy of 33.5%. 
        </p>
        <p class="text">
            Another na√Øve classifier we can create is a single-minded classifier, always guessing the class with the highest representation in the dataset, that is class 1 in this dataset. The accuracy of this one is just the proportion of entries of this class, that is 43.9%. 
        </p>
        <p class="text">
            The single-minded classifier will always do better than the distribution classifier, except for uniform distribution where they will match. Therefore, we will compare the accuracy of the machine learning algorithm classifiers to the single-minded classifier. 
        </p>
        <p class="text">
            As most of the categories are strings, I add to process them to work with the classifier algorithms. I processed the description and the designation by simply reducing them to their length. I ended up dropping the designation length as it was useless and I wanted to focus on the other categories. 
        </p>
        <p class="text">
            The class categories such as country and variety add to be encoded in a way that was understood by the algorithms and reflected the fact that all categories are different and equally different. The best option was to one-hot-encode those categories, that is to split them into as many dimensions as there are values and each entry only features one 1 for each category. 
        </p>
        <p class="text">
            I then scaled the price and the description length to the range from 0 to 1. 
        </p>

        <p class="section">Wine quality</p>

        <p class="text">
            The second dataset is also about wine, but Wine Quality. It is made available by Paulo Cortez from the University of Minho in Portugal on the UCI Machine Learning Repository. This dataset is used in the paper <i>P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis - Modeling wine preferences by data mining from physicochemical properties. In Decision Support Systems, Elsevier, 47(4):547-553, 2009</i>. While the dataset contains data for red and white wines, I restricted my analysis to the white wines because the target classes are less unbalanced.
        </p>
        <p class="text">
            It contains 4898 wines with 11 physiochemical proprieties and a sensory quality score which I will try to predict with a classifier. The physiochemical proprieties are : 
        </p>
        <ul class="text">
            <li>Fixed acidity</li>
            <li>Volatile acidity</li>
            <li>Citric acidity</li>
            <li>Residual sugar</li>
            <li>Chlorides</li>
            <li>Free sulfur dioxide</li>
            <li>Total sulfur dioxide</li>
            <li>Density</li>
            <li>pH</li>
            <li>Sulphates</li>
            <li>Alcohol</li>
        </ul>
        <p class="text">
            All values are floating-point or integer values which I all scaled to the range from 0 to 1.
        </p>
        <p class="text">
            The quality score is on a scale from 0 to 10 but in practice, all the scores are between 3 and 9 but both the scores 3 and 9 each have less than 20 wines. I therefore reclassified 3 in 4 and 9 in 8. I then shifted the rating to start at 0.
        </p>
        <div class="center_block">
            <img class="image_small" src="machinel/Hist_WQ.svg" alt="">
            <p class="caption">
                Distribution of score after grouping
            </p>
        </div>
        <p class="text">
            Similarly to the first dataset, we calculate the accuracy of the na√Øve distribution classifier at 32.4% and the single-minded classifier at 44.9%.
        </p>

        <p class="section">Choices</p>

        <p class="text">
            Both datasets have similar outputs : a 0 to 4 range with a bell-shaped distribution resulting from a subjective measure of the quality of the wines.
        </p>
        <p class="text">
            However, the key differences lie in the inputs. The Wine Reviews feature subjective and human measures as real values : the description length and the price ; and objective geographical and biological categorical values : regions, varieties, country, etc. The Wine Quality only features objective real values.
        </p>
        <p class="text">
            Also, Wine Review is a huge dataset with over 258k valid entries while Wine Quality is much smaller with only 4989 entries. Therefore, it is easier to test the algorithms first with the smaller Wine Quality dataset and then switch to Wine Review.
        </p>

        <p class="section">Pre-analysis</p>

        <p class="text">Before even launching the algorithms, I decided to run some pre-analysis on both datasets to see if there are obvious trends. </p>
        <p class="text">The second dataset, Wine Quality, show very little correlation between the score and any single chemical measure. We can expect the algorithms to struggle more to find accurate rules to classify the entries.</p>
        <p class="text">The first dataset is more intuitive. For instance, French wines have an average score of 88.88 while American wines have an average of 88.16, Italian wines 88.48 and Spanish wines 86.93. <span style="opacity: 0.2">obviously</span></p>
        <p class="text">It is known that, while price and quality doesn‚Äôt correlate exactly for wine, it still is a good approximation and I don‚Äôt recommend buying wines bellow 10$ at the supermarket. Using this dataset, we can plot a scatter of price to points :</p>
        <div class="center_block">
            <img class="image_small" src="machinel/WR_pricepoint.PNG" alt="">
            <p class="caption">
                horizontal : price ; vertical : points on 80-100 scale
            </p>
        </div>
        <p class="text">I removed the values above 1000$ as they are few and they hinder the readability of the interesting part of the scatter plot.</p>
        <p class="text">As we can see, there are no great top-rated wines at very low cost and above 50$ we stop seeing low-rated wines.</p>
        <p class="text">There proprieties come together intuitively as it is often better to buy less famous regions such as Languedoc-Roussillon for 20$ than world famous ones like a Bordeaux for 30$.</p>

        <p class="section">Slicing</p>
        <p class="text">Each dataset is imported, cleaned, normalized and shuffled before being cut. For the experiments, I use a 85% training set-15% testing set as well as a cross-validation with the full dataset cut in x folds. As the Wine review dataset is larger, I will use 10 folds by default but reduce it later when using smaller samples. For the Wine quality dataset, I use 4 folds.</p>


        <p class="chapter">Methodology</p>


        <p class="section">Tools</p>

        <p class="text">Everything was done in Python using Visual Studio Code and the Jupyter extension. The dataset library is Pandas. The machine learning library is SciKit Learn. The plotting library is PyPlot. When possible, I visualize the decision trees with GraphViz.</p>

        <p class="section">Measures and metrics</p>

        <p class="text">I decided to use three different measures of accuracy.</p> 
        <p class="text">The basic test accuracy is the accuracy on the training set (15% of the sample of the dataset) after training on the training set (85%).</p>
        <p class="text">However, the testing set remains the same. When searching optimal hyper-parameters, there is a risk of overfitting on the testing set.</p>
        <p class="text">Therefore, I also used cross validation score. This is the accuracy score I used to choose optimal hyper-parameters. The number of folds I used depends on the size of the dataset. The Wine Review dataset has enough entries to use 10-fold cross validation, while the Wine Quality is too small and I lowered to 4-fold.</p> 
        <p class="text">As both of my datasets are unbalanced, that is the target classes are not filled uniformly but rather in a gaussian-like distribution, the balanced accuracy is useful to measure how unbalanced the guesses are and if minority classes are sacrificed for better accuracy on the majority classes. </p>
        <p class="text">For all classifiers and hyper-parameters, I plot the accuracy on the training set in <span style="background-color: indianred; color: white">red</span>, the accuracy on the testing set in <span style="background-color: mediumseagreen; color: white">green</span> and the cross-validation accuracy in <span style="background-color: steelblue; color: white">blue</span> with the average of all folds as a solid line and the min-max envelope in a <span style="background-color: steelblue; opacity: 0.4; color: white">lighter blue</span>.</p>
        <p class="text">The same colors are used when plotting the learning curves.</p>
        <p class="text">After choosing the optimal hyper-parameters, I plot the confusion matrix on the testing set in absolute and normalized. This is useful to diagnose a poor balanced accuracy score as we can see if some classes are misclassified or completely dropped.</p>


        <p class="chapter">Decision tree</p>


        <p class="section">Wine review</p>

        <p class="text">I first ran the decision tree classifier without any restriction on the number of leaves and the depth and with the measure of split quality set to use entropy of information, on the entire dataset, that in on 258k entries.</p>
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>258k</td>
                <td>89</td>
                <td>63200</td>
                <td>78.0%</td>
                <td>80.2%</td>
                <td>75.7%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/DT_WR_280k_CM.svg" alt="">
            <img class="image_two" src="machinel/DT_WR_280k_NCM.svg" alt="">
        </div>
        <p class="text">The results are significantly better than the na√Øve classifiers.</p>
        <p class="text">As we can see, the classifier works really well on all classes and the errors are mostly only one class away from the truth.</p>
        <p class="text">However, when searching an optimal hyperparameter, we have to fit the classifiers many times. With such a huge dataset, the computation time is just too great. Therefore, I will have to sample the dataset.</p>
        <p class="text">I decided to rerun the decision tree with no restriction on only 80k entries randomly sampled from the dataset.</p>
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>258k</td>
                <td>89</td>
                <td>63200</td>
                <td><b>78.0%</b></td>
                <td><b>80.2%</b></td>
                <td><b>75.7%</b></td>
            </tr>
            <tr>
                <td>80k</td>
                <td>68</td>
                <td>25846</td>
                <td>62.8%</td>
                <td>63.7%</td>
                <td>59.8%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/DT_WR_80k_CM_NP.svg" alt="">
            <img class="image_two" src="machinel/DT_WR_80k_NCM_NP.svg" alt="">
        </div>
        <p class="text">As expected, the tree is smaller, as we encounter less different regions and fewer special cases. However, the accuracy is severely affected. While the confusion matrix looks decent, it is worse than the 258k one. </p>
        <p class="text">This will be a problem when searching the optimal hyperparameters. To demonstrate the methods and the analysis of the method, I will take small samples of the dataset but keeping in mind that working with the whole dataset would produce significantly better results and different optimal hyperparameters. </p>
        <p class="text">I tried pruning the tree with the full 258k dataset and with the reduced 80k dataset. </p>
        <p class="text">First with 258k samples : </p>
        <div class="center_block">
            <img class="image_small" src="machinel/DT_WR_MaxDepth.svg" alt="">
            <img class="image_small" src="machinel/DT_WR_MaxLeaves.svg" alt="">
        </div>
        <p class="text">Here no maximum is reached before the previous result and pruning the leaves would result is a significantly lower accuracy. Overfitting isn‚Äôt a problem with this dataset. </p>
        <p class="text">We can still prune the depth to 50 without affecting the accuracy much. </p>
        <div class="center_block">
            <img class="image_small" src="machinel/DT_WR_280k_P_LC.svg" alt="">
        </div>
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>258k</td>
                <td>89</td>
                <td>63200</td>
                <td><b>78.0%</b></td>
                <td><b>80.2%</b></td>
                <td><b>75.7%</b></td>
            </tr>
            <tr>
                <td>258k pruned</td>
                <td>50</td>
                <td>60940</td>
                <td>77.5%</td>
                <td>79.5%</td>
                <td>75.3%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/DT_WR_280k_P_CM.svg" alt="">
            <img class="image_two" src="machinel/DT_WR_280k_P_NCM.svg" alt="">
        </div>
        <p class="text">As expected, the performances are slightly degraded. The number of leaves barely decreased so this pruning probably only cut some thin and long branches of the tree. The confusion matrix shows that the pruning affected the minority classes the most. As we can see on the learning curves, more sample would improve the accuracy even more.</p>
        <p class="text">Then with 80k : </p>
        <div class="center_block">
            <img class="image_small" src="machinel/DT_WR_80k_MaxDepth.svg" alt="">
            <img class="image_small" src="machinel/DT_WR_80k_MaxLeaves.svg" alt="">
        </div>
        <p class="text">Again, while the accuracy almost plateaus after a certain tree size, it still increases slightly and there is no problem with overfitting. We can still prune this tree to a depth of 10. I then checked if the optimal number of leaves would could be lowered in this case. </p>
        <div class="center_block">
            <img class="image_small" src="machinel/DT_WR_80k_MaxLeaves_P.svg" alt="">
        </div>
        <p class="text">And indeed it can. We can thus prune the tree to a depth of 10 and maximum 200 leaves. </p>
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>80k</td>
                <td>68</td>
                <td>25846</td>
                <td><b>62.8%</b></td>
                <td><b>63.7%</b></td>
                <td><b>59.8%</b></td>
            </tr>
            <tr>
                <td>80k pruned</td>
                <td>10</td>
                <td>200</td>
                <td>61.4%</td>
                <td>61.1%</td>
                <td>41.0%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/DT_WR_80k_CM.svg" alt="">
            <img class="image_two" src="machinel/DT_WR_80k_NCM.svg" alt="">
        </div>
        <p class="text">While the testing and cross-validation accuracy scores were not affected much, the balanced accuracy dropped by almost 20% and all class 4 entries were misclassified as class 3 or 2. </p>

        <p class="section">Wine quality</p>

        <p class="text">As this set is small with only 4898 entries, I used the full set. The testing set is 15% of the total dataset. </p> 
        <p class="text">Again, I first ran the decision tree classifier without any restriction on the number of leaves and the depth and with the measure of split quality set to use entropy of information. </p> 
        
        <div class="center_block">
            <img class="image_small" src="machinel/DT_WQ_NP_LC.svg" alt="">
        </div>
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>not pruned</td>
                <td>22</td>
                <td>1027</td>
                <td>59.0%</td>
                <td>41.9%</td>
                <td>48.4%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/DT_WQ_NP_CM.svg" alt="">
            <img class="image_two" src="machinel/DT_WQ_NP_NCM.svg" alt="">
        </div>
        <p class="text">The results are good for the center majority classes, but really poor for the extremes. The class 0 is more often classified as 1 or 2, while the score for class 4 is worse than the na√Øve classifiers. This is reflected by the poor balanced accuracy. </p> 
        <p class="text">The accuracy is worse than the na√Øve classifiers. </p> 
        <p class="text">I tried pruning the tree to see if this was due to overfitting. Thus, I modified the hyperparameters for the maximum depth and the maximum number of leaves.</p> 
        <div class="center_block">
            <img class="image_small" src="machinel/DT_WQ_MaxDepth.svg" alt="">
            <img class="image_small" src="machinel/DT_WQ_MaxLeaves.svg" alt="">
        </div>
        <p class="text">As we can see, while the testing accuracy keeps improving, the cross-validation accuracy reaches a peak score for a depth of 4 and 10 leaves only</p>
        <div class="center_block">
            <img class="image_small" src="machinel/DT_WQ_P_LC.svg" alt="">
        </div>
        <div class="center_block">
            <img class="image_big" src="machinel/DT_WQ_FULL_PRUNNED.svg" alt="">
        </div>
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>not pruned</td>
                <td>22</td>
                <td>1027</td>
                <td><b>59.0%</b></td>
                <td>41.9%</td>
                <td><b>48.4%</b></td>
            </tr>
            <tr>
                <td>pruned</td>
                <td>4</td>
                <td>10</td>
                <td>48.4%</td>
                <td><b>51.1%</b></td>
                <td>30.5%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/DT_WQ_P_CM.svg" alt="">
            <img class="image_two" src="machinel/DT_WQ_P_NCM.svg" alt="">
        </div>
        <p class="text">Comparing to the classifier before pruning, the cross-validation accuracy increased significantly by 10%, however, the test accuracy and more importantly the balance accuracy fell drastically. </p> 
        <p class="text">The confusion matrix shows what happens. The classifier tends to squeeze the values towards the center, and the classes 0 and 4 are almost dropped. This classifier is closer to the na√Øve classifiers as it drops the minority classes in favor of the majority classes. </p> 
        <p class="text">This is also visible on the graph of the decision tree. </p> 
        <p class="text">The decision tree is difficult to prune for this dataset and that might be because the minority classes are not so different from the majority and the extra leaves are used to fine tune the classification on the special details.</p> 

        <p class="section">Overall</p>

        <p class="text">On the Wine review dataset using a large sample or the whole dataset, pruning resulted in worse results than the largest tree. However, on the smaller Wine quality dataset, pruning reduced overfitting and improved cross-validation accuracy. </p> 
        <p class="text">In both cases, the balanced accuracy got severely reduced so pruning might not be recommended for unbalanced datasets but further examination of this assumption is required. </p> 


        <p class="chapter">Boosting</p>


        <p class="section">Wine review</p>

        <p class="text">I first tried to run the study on the pruned decision tree obtained with the 80k sample of the dataset in the previous chapter. However, the computation time was again too large and I had to shrink the dataset to a tiny 5k sample. I ran the decision tree on it and pruned it successfully. </p> 
        <div class="center_block">
            <img class="image_small" src="machinel/DT_WR_5k_MaxDepth.svg" alt="">
            <img class="image_small" src="machinel/DT_WR_5k_MaxLeaves.svg" alt="">
        </div>
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>5k</td>
                <td>48</td>
                <td>1681</td>
                <td>51.3%</td>
                <td>51.0%</td>
                <td><b>37.9%</b></td>
            </tr>
            <tr>
                <td>5k pruned</td>
                <td>5</td>
                <td>31</td>
                <td><b>60.0%</b></td>
                <td><b>59.1%</b></td>
                <td>37.0%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/DT_WR_5k_CM.svg" alt="">
            <img class="image_two" src="machinel/DT_WR_5k_NCM.svg" alt="">
        </div>
        <p class="text">The two hyper-parameters I chose to study are the learning rate and the number of estimators used, starting with the former while leaving the latter to the default value of 50</p>
        <div class="center_block">
            <img class="image_small" src="machinel/BST_WR_5k_LearnRate_log.svg" alt="">
        </div>
        <p class="text">Here, the default learning rate of 1 is not the optimal value. I chose a learning rate of 0.01 for this step, meaning each estimator contributes less to the total, and more estimators should be required. </p> 
        <p class="text">Thus, I fixed the learning rate at that value and varied the number of estimators.</p> 
        <div class="center_block">
            <img class="image_small" src="machinel/BST_WR_5k_Est.svg" alt="">
        </div>
        <p class="text">The testing accuracy curve is unexpected but the cross-validation shows an optimal parameter around 30. As the peak seems rather sharp, I decided to fine tune it even further. </p> 
        <div class="center_block">
            <img class="image_small" src="machinel/BST_WR_5k_Est2.svg" alt="">
        </div>
        <p class="text">Anything from 28 to 35 is a good choice. Thus, I chose the parameters of a learning rate of 0.01 and 35 estimators.</p>
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>5k</td>
                <td>48</td>
                <td>1681</td>
                <td>51.3%</td>
                <td>51.0%</td>
                <td><b>37.9%</b></td>
            </tr>
            <tr>
                <td>5k pruned</td>
                <td>5</td>
                <td>31</td>
                <td><b>60.0%</b></td>
                <td>59.1%</td>
                <td>37.0%</td>
            </tr>
            <tr>
                <td>5k boosted</td>
                <td></td>
                <td></td>
                <td>58.3%</td>
                <td><b>60.0%</b></td>
                <td>34.8%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/BST_WR_5k_CM.svg" alt="">
            <img class="image_two" src="machinel/BST_WR_5k_NCM.svg" alt="">
        </div>
        <p class="text">The boosting didn‚Äôt improve the accuracy scores much and was pretty much unnecessary. </p> 
        <p class="text">I then made the very questionable assumption that these optimal parameters can be used the larger 80k sample of the full dataset. </p> 
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>80k</td>
                <td>68</td>
                <td>25846</td>
                <td><b>62.8%</b></td>
                <td><b>63.7%</b></td>
                <td><b>59.8%</b></td>
            </tr>
            <tr>
                <td>80k pruned</td>
                <td>10</td>
                <td>200</td>
                <td>61.4%</td>
                <td>61.1%</td>
                <td>41.0%</td>
            </tr>
            <tr>
                <td>80k boosted</td>
                <td></td>
                <td></td>
                <td>61.7%</td>
                <td>61.7%</td>
                <td>39.9%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/BST_WR_80k_CM.svg" alt="">
            <img class="image_two" src="machinel/BST_WR_80k_NCM.svg" alt="">
        </div>
        <p class="text">The cross-validation and testing accuracy scores improved slightly while the balanced accuracy stayed almost unaffected. This shows that boosting can improve performance on the larger dataset but a proper optimization of the hyperparameters is required to take full advantage of this algorithm.</p>

        <p class="section">Wine quality</p>

        <p class="text">As the pruning of the decision tree was unsuccessful, I initially decided to run the study of the hyperparameters for the Boosting algorithm on both the pruned and not-pruned decision trees, however the performance of the unpruned tree did not improve at all. Indeed, the tree is already almost overfitting. Therefore, the analysis of the hyperparameters is only relevant on the pruned tree from the previous part.  </p> 
        <p class="text">Again, I started by tuning the learning rate with the default 50 estimators. </p> 
        <div class="center_block">
            <img class="image_small" src="machinel/BST_WQ_P_LearnRate_Log.svg" alt="">
        </div>
        <p class="text">And again, the best learning rate is around 0.01. </p> 
        <p class="text">I fixed the learning rate at that value and varied the number of estimators, first exponentially and then between 1 and 100.</p> 
        <div class="center_block">
            <img class="image_small" src="machinel/BST_WQ_P_Est_log.svg" alt="">
            <img class="image_small" src="machinel/BST_WQ_P_Est.svg" alt="">
        </div>
        <p class="text">This plot isn‚Äôt as clear but we can still tell that about 40 estimators is slightly better. This is slightly less than the default value of 50 even though we lowered the learning rate by two orders of magnitude, however the variation with this hyperparameter isn‚Äôt striking.  </p> 
        <p class="text">I checked that reducing the number of estimators from 50 to 40 didn‚Äôt affect the optimal learning rate much and the results are the same. This is a sort of gradient ascent method to finding a local maximum of accuracy in a landscape of hyperparameters. </p> 
        <p class="text">Therefore, the optimal hyperparameters are a learning rate of 0.01 and 40 estimators.</p> 
        <div class="center_block">
            <img class="image_small" src="machinel/BST_WQ_Opti_LR.svg" alt="">
        </div>
        <table>
            <tr>
                <th></th>
                <th>Depth</th>
                <th>Leaves</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>not pruned</td>
                <td>22</td>
                <td>1027</td>
                <td><b>59.0%</b></td>
                <td>41.9%</td>
                <td><b>48.4%</b></td>
            </tr>
            <tr>
                <td>pruned</td>
                <td>4</td>
                <td>10</td>
                <td>48.4%</td>
                <td>51.1%</td>
                <td>30.5%</td>
            </tr>
            <tr>
                <td>boosted</td>
                <td></td>
                <td></td>
                <td>50.1%</td>
                <td><b>52.3%</b></td>
                <td>28.6%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/BST_WQ_CM.svg" alt="">
            <img class="image_two" src="machinel/BST_WQ_NCM.svg" alt="">
        </div>
        <p class="text">Compared to the original tree before and after pruning, we can observe that the cross-validation accuracy increased again as this is the metric I used to choose the optimal hyperparameters. The testing accuracy recovered slightly but this metric isn‚Äôt really relevant. However, the balanced accuracy fell again. This is clearly visible on the confusion matrix. This time, in addition to classes 0 and 4, class 3 has also be dropped and the classifier is pretty much just guessing class 2 66% of the time. </p>

        <p class="section">Overall</p>

        <p class="text">Both datasets showed slightly better results for a learning rate of around 0.01 instead of the default 1 and around 30 to 40 estimators, slightly fewer than the default 50. </p> 
        <p class="text">On both datasets, balanced accuracy fell drastically. </p> 


        <p class="chapter">K-Nearest neighbors</p>


        <p class="text">As the training score will always be 100% with KNN, it will be hidden in all the plots of this chapter</p>

        <p class="section">Wine review</p>

        <p class="text">I first tried KNN with low values of K but could still not get the peak so I used a logarithmic scale again. I also chose Euclidean distance and distance weight for this run. </p>
        <div class="center_block">
            <img class="image_small" src="machinel/KNN_WR_dist_eucl.svg" alt="">
        </div>
        <p class="text">The optimal number of neighbors is around 200 but a large range of values produce similar results. </p> 
        <p class="text">I then removed the distance weight and switched it to uniform. </p> 
        <div class="center_block">
            <img class="image_small" src="machinel/KNN_WR_unif_eucl.svg" alt="">
        </div>
        <p class="text">Here the peak accuracy is reached around 40 neighbors and proves better than distance weight. </p> 
        <p class="text">I also tried different distance metrics but the results were very similar and not interesting to include. </p> 
        <p class="text">The parameter I chose are a value of K of 40 with Euclidean distance and weight set to uniform. </p> 
        <table>
            <tr>
                <th></th>
                <th>K</th>
                <th>Distance</th>
                <th>Weight</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>5k</td>
                <td>40</td>
                <td>euclidean</td>
                <td>uniform</td>
                <td>55.3%</td>
                <td>57.2%</td>
                <td>31.9%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/KNN_WR_5k_CM.svg" alt="">
            <img class="image_two" src="machinel/KNN_WR_5k_NCM.svg" alt="">
        </div>
        <p class="text">I then again made the questionable assumption that these optimal parameters can be used the larger 80k sample of the full dataset. </p>
        <table>
            <tr>
                <th></th>
                <th>K</th>
                <th>Distance</th>
                <th>Weight</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>80k</td>
                <td>40</td>
                <td>euclidean</td>
                <td>uniform</td>
                <td>59.1%</td>
                <td>59.4%</td>
                <td>37.6%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/KNN_WR_80k_CM.svg" alt="">
            <img class="image_two" src="machinel/KNN_WR_80k_NCM.svg" alt="">
        </div>
        <p class="text">The results are better than with the smaller sample as the point density is greater. </p> 
        <p class="text">As I encoded the categories of the dataset as 1s and 0s in a large sparse array, I also experimented with the distance metrics dedicated to Boolean values. They all gave similar results and didn‚Äôt show an improvement from the Euclidean distance. Here are the results for the Jaccard distance. </p> 
        <div class="center_block">
            <img class="image_small" src="machinel/KNN_WR_unif_jacc.svg" alt="">
        </div>
        <table>
            <tr>
                <th></th>
                <th>K</th>
                <th>Distance</th>
                <th>Weight</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>5k</td>
                <td>40</td>
                <td>euclidean</td>
                <td>uniform</td>
                <td><b>55.3%</b></td>
                <td><b>57.2%</b></td>
                <td><b>31.9%</b></td>
            </tr>
            <tr>
                <td>5k</td>
                <td>50</td>
                <td>jaccard</td>
                <td>uniform</td>
                <td>47.6%</td>
                <td>46.1%</td>
                <td>24.1%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/KNN_WR_unif_jacc_CM.svg" alt="">
            <img class="image_two" src="machinel/KNN_WR_unif_jacc_NCM.svg" alt="">
        </div>

        <p class="section">Wine quality</p>

        <p class="text">Similarly, I ran KNN with different values of K and I also chose Euclidean distance and distance weight. </p>
        <div class="center_block">
            <img class="image_small" src="machinel/KNN_WQ_dist_eucl.svg" alt="">
        </div>
        <p class="text">To reach a peak accuracy, we need a value of K in the neighborhood of 200, or about 20% of the whole dataset. As the neighbors are weighted by distance, the fact that the optimal K is rather high indicates the points are very close and not we separated, as expected during the pre-analysis. The cross-validation accuracy still is only about 53%. </p> 
        <p class="text">I then tested to remove the distance weighting and keep the Euclidean distance. </p> 
        <div class="center_block">
            <img class="image_small" src="machinel/KNN_WQ_unif_eucl.svg" alt="">
        </div>
        <p class="text">While the cross-validation results are almost identical, the testing accuracy starts very high for ùêæ = 1 and drop significantly.  </p> 
        <p class="text">This result is very surprising. The cross-validation uses 4 folds for this set while the training-testing uses a 85-15% split ; so when testing, the cross-validation searches neighbors in 75% of the dataset while the regular training-testing (green curve) searches in 85% of the dataset. Thus, the latter has a higher density than the former and a tested point would have more close neighbors with training-testing and thus a better score while the cross-validation would pick points further away and possibly less similar. A weighted with distance criteria would mitigate this effect. However We observe the opposite : the cross-validation is unaffected by the weight but the trainingtesting is. </p> 
        <p class="text">I then tested other distance functions : Manhattan and Chebyshev, both with and without distance weight, but the results are so similar to the two with Euclidean that they are not worth including. </p> 
        <p class="text">Therefore, an optimal classifier would be a KNN with a K of 200, Euclidean distance and weighted by distance.</p> 
        <table>
            <tr>
                <th>K</th>
                <th>Distance</th>
                <th>Weight</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>200</td>
                <td>euclidean</td>
                <td>distance</td>
                <td>64.1%</td>
                <td>52.8%</td>
                <td>45.4%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/KNN_WQ_dist_eucl_CM.svg" alt="">
            <img class="image_two" src="machinel/KNN_WQ_dist_eucl_NCM.svg" alt="">
        </div>
        <p class="text">While the accuracies are decent, the confusion matrix reveals that, again, the extremes are dropped. This still results in a decent balanced accuracy though. </p>

        <p class="section">Overall</p>

        <p class="text">On both datasets, the different distance metrics didn‚Äôt change the results much.  </p> 
        <p class="text">The datasets required different values of K, and as I took 5k samples for the Wine review and the Wine quality is almost 5k samples long, we can assume that the number of neighbors to pick depends heavily on the problem. </p> 


        <p class="chapter">Support Vector Machine</p>


        <p class="section">Wine review</p>

        <p class="text">The SVC algorithm is much more computation-heavy, I reduced the dataset to only 10000 samples at first.  </p> 
        <p class="text">The first hyperparameter I studied is the kernel. I tried all available kernels. I tried to vary the order of the polynomial kernel up to 5 but the computation time was already one hour for the third order. </p> 
        <table>
            <tr>
                <th>Kernel</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>RBF</td>
                <td>54.1%</td>
                <td>54.5%</td>
                <td>31.0%</td>
            </tr>
            <tr>
                <td>sigmoid</td>
                <td>40.0%</td>
                <td>21.4%</td>
                <td>20.9%</td>
            </tr>
            <tr>
                <td>linear</td>
                <td><b>59.0%</b></td>
                <td><b>58.2%</b></td>
                <td>34.2%</td>
            </tr>
            <tr>
                <td>poly 0</td>
                <td>41.5%</td>
                <td>43.5%</td>
                <td>20.0%</td>
            </tr>
            <tr>
                <td>poly 1</td>
                <td>53.9%</td>
                <td>53.4%</td>
                <td>27.9%</td>
            </tr>
            <tr>
                <td>poly 2</td>
                <td>51.9%</td>
                <td>52.3%</td>
                <td>27.2%</td>
            </tr>
            <tr>
                <td>poly 3</td>
                <td>53.1%</td>
                <td>53.3%</td>
                <td><b>35.7%</b></td>
            </tr>
        </table>
        <p class="text">I won‚Äôt include every confusion matrix as it is not very relevant. </p> 
        <p class="text">We can observe that the linear kernel is the most accurate in testing and cross-validation tests, and second best in balanced accuracy. The best for balanced accuracy is actually the third-order polynomial. </p> 
        <div class="center_block">
            <img class="image_two" src="machinel/SVM_WR_Linear_CM.svg" alt="">
            <img class="image_two" src="machinel/SVM_WR_Linear_NCM.svg" alt="">
            <p class="caption">Linear kernel</p>
            <img class="image_two" src="machinel/SVM_WR_poly3_CM.svg" alt="">
            <img class="image_two" src="machinel/SVM_WR_poly3_NCM.svg" alt="">
            <p class="caption">Poly 3 kernel</p>
        </div>
        <p class="text">Looking at the confusion matrices, we can see that the sample of the dataset only included three entries of class 4. Both kernels misclassified one of class 4 in class 2 and one in class 3, but the linear misclassified one more in class 3 while the polynomial got one right, boosting the accuracy for this class to 33% against 0%, thus boosting the balanced accuracy. This is not significant at all and the linear kernel can be considered optimal.  </p> 
        <p class="text">I then tried to study the effect of the penalty coefficient C for the linear kernel. An exhaustive search would have studied this parameter for all kernels, but the computation time is too large for such search so I assume that the linear kernel is better regardless of C. </p> 
        <p class="text">For this dataset, the computation time is just too large and I reduced the dataset even further to only 5000 samples for the study of C but the computation still took hours per value of C. Therefore, I canceled this study for this dataset. </p> 

        <p class="section">Wine quality</p>

        <p class="text">Similarly, I tested every kernel with this dataset. As this dataset is smaller, I was able to compute the polynomial up to the fifth order. </p>
        <table>
            <tr>
                <th>Kernel</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>RBF</td>
                <td>46.1%</td>
                <td>49.9%</td>
                <td>24.6%</td>
            </tr>
            <tr>
                <td>sigmoid</td>
                <td>45.2%</td>
                <td>47.9%</td>
                <td>23.2%</td>
            </tr>
            <tr>
                <td>linear</td>
                <td><b>47.2%</b></td>
                <td><b>50.9%</b></td>
                <td><b>25.5%</b></td>
            </tr>
            <tr>
                <td>poly 0</td>
                <td>41.6%</td>
                <td>44.9%</td>
                <td>20.0%</td>
            </tr>
            <tr>
                <td>poly 1</td>
                <td>45.2%</td>
                <td>47.9%</td>
                <td>23.2%</td>
            </tr>
            <tr>
                <td>poly 2</td>
                <td>41.6%</td>
                <td>44.9%</td>
                <td>20.0%</td>
            </tr>
            <tr>
                <td>poly 3</td>
                <td>41.6%</td>
                <td>44.9%</td>
                <td>20.0%</td>
            </tr>
            <tr>
                <td>poly 4</td>
                <td>41.6%</td>
                <td>44.9%</td>
                <td>20.0%</td>
            </tr>
            <tr>
                <td>poly 5</td>
                <td>41.6%</td>
                <td>44.9%</td>
                <td>20.0%</td>
            </tr>
        </table>
        <p class="text">Something unexpected happened with the polynomial kernel. The accuracy scores and the confusion matrices are all the same for order zero and two to five, but not compared to the first order which got better results. The linear kernel once again is the best of the bunch. </p>
        <div class="center_block">
            <img class="image_two" src="machinel/SVM_WQ_Linear_CM.svg" alt="">
            <img class="image_two" src="machinel/SVM_WQ_Linear_NCM.svg" alt="">
            <p class="caption">Linear kernel</p>
            <img class="image_two" src="machinel/SVM_WQ_poly0_CM.svg" alt="">
            <img class="image_two" src="machinel/SVM_WQ_poly0_NCM.svg" alt="">
            <p class="caption">Poly 0 & 2-5 kernels</p>
            <img class="image_two" src="machinel/SVM_WQ_poly1_CM.svg" alt="">
            <img class="image_two" src="machinel/SVM_WQ_poly1_NCM.svg" alt="">
            <p class="caption">Poly 1 kernel</p>
        </div>
        <p class="text">We can see that the polynomial classifier with an order different from 1 is just the na√Øve single-minded classifier while the first order polynomial and the linear guess class 1 sometimes and class 2 most of the time. </p>
        <p class="text">Again, I searched the optimal value of the penalty coefficient C for the linear kernel only. Even with this smaller dataset, the computation time was high. </p>
        <div class="center_block">
            <img class="image_small" src="machinel/SVM_WQ_linear_C.svg" alt="">
        </div>
        <p class="text">We can observe the optimal penalty factor is around 3.5. </p>
        <div class="center_block">
            <img class="image_small" src="machinel/SVM_WQ_LC.svg" alt="">
        </div>
        <table>
            <tr>
                <th>kernel</th>
                <th>C</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>linear</td>
                <td>1.0</td>
                <td><b>47.2%</b></td>
                <td>50.9%</td>
                <td><b>25.5%</b></td>
            </tr>
            <tr>
                <td>linear</td>
                <td>3.5</td>
                <td>46.9%</td>
                <td><b>51.2%</b></td>
                <td>25.4%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/SVM_WQ_LinearC_CM.svg" alt="">
            <img class="image_two" src="machinel/SVM_WQ_LinearC_NCM.svg" alt="">
        </div>
        <p class="text">The accuracy scores are decent compared to the na√Øve classifiers even though the minority classes are completely dropped.</p>

        <p class="section">Overall</p>

        <p class="text">For both datasets, the optimal kernel is the linear kernel. The value of C could only be studied on the Wine quality dataset and shown good results with a value of 3.5.</p>


        <p class="chapter">Neural network</p>


        <p class="text">As this algorithm requires many tries, I decided to start by explaining my experiments with the smaller Wine quality dataset and then briefly apply those observations and results to the other dataset.</p>

        <p class="section">Wine quality</p>

        <p class="text">First, I wanted to know how much the initial weights and biases of the network affects the accuracy scores so I ran the training with the same parameters five times and the differences in accuracy was less than 2% from run to run. I also increased the maximum number of iterations in order to make sure we reached a local maximum of accuracy at least. </p>
        <p class="text">I then thought about a methodology to search the best network structure. But there are just too many options such as number of layers, number of neurons in each layer, shapes of the structure (increasing number of neurons, decreasing number of neurons, concave, convex, etc). I started with two equal layers with increasing number of neurons.</p>
        <div class="center_block">
            <img class="image_small" src="machinel/NN_WQ_NbLayer2.svg" alt="">
        </div>
        <p class="text">The trend isn‚Äôt clear. I then tried varying the number of layers but again the accuracy scores are all over the place. I ended up trying many different structures randomly. The 1212-12 structure led to the best results. </p>
        <p class="text">Then I studied the impact of different activation functions with the 12-12-12 network. </p>
        <table>
            <tr>
                <th>Network</th>
                <th>Activation</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>12-12-12</td>
                <td>identity</td>
                <td>49.8%</td>
                <td>52.0%</td>
                <td>30.4%</td>
            </tr>
            <tr>
                <td>12-12-12</td>
                <td>relu</td>
                <td><b>52.7%</b></td>
                <td><b>52.9%</b></td>
                <td><b>34.2%</b></td>
            </tr>
            <tr>
                <td>12-12-12</td>
                <td>logistic</td>
                <td>41.6%</td>
                <td>46.2%</td>
                <td>20.0%</td>
            </tr>
            <tr>
                <td>12-12-12</td>
                <td>tanh</td>
                <td><b>52.7%</b></td>
                <td>52.4%</td>
                <td>33.5%</td>
            </tr>
        </table>
        <p class="text">In this case, the relu activation produced the best results especially compared to the famous logistic sigmoid. This was very unexpected to me. Tanh also produced decent results. </p>
        <div class="center_block">
            <img class="image_small" src="machinel/NN_WQ_LC.svg" alt="">
        </div>
        <table>
            <tr>
                <th>Network</th>
                <th>Activation</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>12-12-12</td>
                <td>relu</td>
                <td>52.7%</td>
                <td>52.9%</td>
                <td>34.2%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/NN_WQ_CM.svg" alt="">
            <img class="image_two" src="machinel/NN_WQ_NCM.svg" alt="">
        </div>

        <p class="section">Wine review</p>

        <p class="text">As the computation load with this dataset is huge, I decided to reuse the observations of the other dataset. Therefore, I used the same parameters. </p>
        <div class="center_block">
            <img class="image_small" src="machinel/NN_WR_LC.svg" alt="">
        </div>
        <table>
            <tr>
                <th>Network</th>
                <th>Activation</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>12-12-12</td>
                <td>relu</td>
                <td>59.8%</td>
                <td>60.5%</td>
                <td>49.2%</td>
            </tr>
        </table>
        <div class="center_block">
            <img class="image_two" src="machinel/NN_WR_CM.svg" alt="">
            <img class="image_two" src="machinel/NN_WR_NCM.svg" alt="">
        </div>


        <p class="chapter">Conclusion</p>


        <p class="section">Wine review</p>

        <table>
            <tr>
                <th>Algorithm</th>
                <th>Sample size</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>Distribution</td>
                <td></td>
                <td colspan="2">33.5%</td>
                <td></td>
            </tr>
            <tr>
                <td>Single-minded</td>
                <td></td>
                <td colspan="2">43.9%</td>
                <td></td>
            </tr>
            <tr>
                <td>Decision tree unpruned</td>
                <td>258k <br> 80k <br> 5k</td>
                <td><b>78.0%</b> <br> 62.8% <br> 51.3%</td>
                <td><b>80.2%</b> <br> 63.7% <br> 51.0%</td>
                <td><b>75.7%</b> <br> 59.8% <br> 37.9%</td>
            </tr>
            <tr>
                <td>Decision tree pruned</td>
                <td>258k <br> 80k <br> 5k</td>
                <td>77.5% <br> 61.4% <br> 60.0%</td>
                <td>80.2% <br> 61.1% <br> 59.1%</td>
                <td>75.7% <br> 41.0% <br> 37.0%</td>
            </tr>
            <tr>
                <td>Boosting</td>
                <td>80k <br> 5k</td>
                <td>61.7% <br> 58.3%</td>
                <td>61.7% <br> 60.0%</td>
                <td>39.9% <br> 34.8%</td>
            </tr>
            <tr>
                <td>KNN</td>
                <td>80k <br> 5k</td>
                <td>59.1% <br> 55.3%</td>
                <td>59.4% <br> 57.2%</td>
                <td>37.6% <br> 31.9%</td>
            </tr>
            <tr>
                <td>SVM</td>
                <td>10k</td>
                <td>59.0%</td>
                <td>58.2%</td>
                <td>34.2%</td>
            </tr>
            <tr>
                <td>NN</td>
                <td>10k</td>
                <td>59.5%</td>
                <td>60.9%</td>
                <td>43.0%</td>
            </tr>
        </table>

        <p class="section">Wine quality</p>

        <table>
            <tr>
                <th>Algorithm</th>
                <th>Test accuracy</th>
                <th>Crossval accuracy</th>
                <th>Balanced accuracy</th>
            </tr>
            <tr>
                <td>Distribution</td>
                <td colspan="2">32.4%</td>
                <td></td>
            </tr>
            <tr>
                <td>Single-minded</td>
                <td colspan="2">44.9%</td>
                <td></td>
            </tr>
            <tr>
                <td>Decision tree unpruned</td>
                <td>59.0%</td>
                <td>41.9%</td>
                <td>48.4%</td>
            </tr>
            <tr>
                <td>Decision tree pruned</td>
                <td>48.4%</td>
                <td>51.1%</td>
                <td>30.5%</td>
            </tr>
            <tr>
                <td>Boosting</td>
                <td>50.1%</td>
                <td>52.3%</td>
                <td>28.6%</td>
            </tr>
            <tr>
                <td>KNN</td>
                <td><b>64.1%</b></td>
                <td>52.8%</td>
                <td><b>45.4%</b></td>
            </tr>
            <tr>
                <td>SVM</td>
                <td>46.9%</td>
                <td>51.2%</td>
                <td>25.4%</td>
            </tr>
            <tr>
                <td>NN</td>
                <td>52.7%</td>
                <td><b>52.9%</b></td>
                <td>34.2%</td>
            </tr>
        </table>

        <p class="text">For the Wine review dataset, the best results were obtained for the unpruned decision tree with the full dataset. However, if all algorithms were fit with the full dataset, assuming the ranking would stay the same as with the smaller 5k and 10k samples, the best algorithm would be Boosting. </p>
        <p class="text">For the Wine quality dataset, the results are a bit more varied. KNN shows the best performance for testing and cross-validation, NN show the best performance for cross-validation and the unpruned decision tree is better for balanced accuracy.</p>
        

        <br><br>
        <div class="iconlabel">
            <img src="github.svg" alt="">
            <a class="link" href="https://github.com/Louis-DR/SupervisedLearning">
                See the project on GitHub
            </a>
        </div>


        <br><br><br><br><br><br><br>
        <p class="section">Funny story</p>
        <p class="text">
            This project took over 50 hours over the span of a week (yes I was not properly organized and should have started earlier). The deadline was on Monday at 5am in my timezone. At 4am, I had just finished. Office Word on which I wrote my report crashed... and somehow deleted the file ! Fortunately, just hours before, I had removed files from my DropBox to reduce the size of the folder bellow the 2Gb limit of the free version above which it stops syncing. However ! Dropbox also synced the removal of the file and disabling the internet immediately was not fast enough. FORTUNATELY ! (again) Dropbox actually backs up the file even if we delete them so I was able to recover it... This was the single most terrifying experience I had, and my most intense Near Death Experience.
        </p>
        <p class="text">
            Lesson of the story, make regular backups, even if you use cloud sync.
        </p>

        <a id="indexlink" href="index.html" style="margin-top: 60px">
            Go back to the list of projects
        </a>
        <script>
            renderMathInElement(document.body,{delimiters: [
                {left: "$$", right: "$$", display: false},
                {left: "¬£¬£", right: "¬£¬£", display: true}
            ]});
        </script>
    </div>
</body>
</html>